---
title: "DA 401 Early Results"
author: "Calvin Burzynski"
date: "2025-10-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(dplyr)
library(tidyr)
library(stringr)
library(lubridate)
library(readr)
library(ggplot2)
library(fixest)
library(janitor)
library(broom)
library(data.table)
library(did)


#load in ipums (acs) dataset
ipums <- fread("./../data/usa_00005.csv.gz") #used fread from the data.table package as the file is large and this allowed it to be loaded in much quicker

#load minimum wage DOL data
min_wage_data <- fread("./../data/Minimum Wage from DOL 2010-2023.csv") #used fread to avoid X in front of year column names

#load monthly unemployment rate data
unemployment_rate_data <- read.csv("./../data/state_unemploy_panel_copy_paste.csv")

gdp_income <- read.csv("./../data/State Annual Summary Statistics GDP Income.csv", skip = 3)

cpi <- read_csv("./../data/CPI_all_urban_import.csv") #got warning but data loaded in just fine

tail(ipums)
```
```{r}
#clean cpi a bit
cpi2 <- cpi %>%
  rename(year=Year) %>%
  transmute(
    year = as.integer(year), 
    cpi_u = as.numeric(Annual)
  ) 
```


```{r}
#reusable visual theme for graphs 
theme_slide <- theme_minimal(base_size = 13) + 
  theme(
    plot.title.position = "plot",
    plot.title = element_text(face = "bold"), 
    plot.subtitle = element_text(margin = margin(b = 10)), 
    plot.caption = element_text(size = 9, color = "grey40"), 
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    axis.title.y = element_text(margin = margin(r = 8)),
    axis.title.x = element_text(margin = margin(t = 8)),
    legend.position = "bottom"
  )
```


```{r}
#filter for poverty status
ipums %>%
  distinct(POVERTY) %>%
  arrange(POVERTY) #investigating values of poverty 
summary(ipums$POVERTY)
summary(ipums$EMPSTAT)

```


```{r}
ipums_poverty <- ipums %>%
  filter(EMPSTAT == 1, UHRSWORK >= 35, WKSWORK2 >= 6, AGE >= 18, AGE <= 64) %>%
  mutate(POVERTY = as.numeric(POVERTY)) %>%
  mutate(in_poverty = case_when(
    is.na(POVERTY) ~ NA_real_,
    POVERTY < 100 ~ 1, 
    POVERTY >= 100 ~ 0
  ), 
    low_wage = if_else(POVERTY <= 150, 1L, 0L, missing = NA_integer_) #using 150 as the cutoff as most analyses go beyond strict poverty to include near-poor population. Many federal programs use 125 to 150% and my analysis focuses on poverty or near poverty populations
  ) %>%
  filter(low_wage == 1) %>%
  group_by(STATEFIP, YEAR) %>%
  summarise(
    poverty_rate = weighted.mean(in_poverty, w = PERWT, na.rm = T), #weighted poverty indicator
    pop_weight = sum(PERWT, na.rm = T), 
    .groups = "drop"
  )
#pop_weight represents the estimated total number of individuals represented by the ACS sample in that state-year 
```


```{r}
min_wage_long <- min_wage_data %>%
  rename_with(~str_remove(., "^X"), starts_with("X")) %>% #cleans columns with 'X' prefix
  pivot_longer(
    cols = all_of(as.character(2010:2023)),
    names_to = "YEAR",
    values_to = "min_wage"
  ) %>%
  mutate(
    YEAR = as.numeric(YEAR)
  ) %>%
  filter(between(YEAR, 2010, 2023))

min_wage_long <- min_wage_long %>%
  rename(state=State) %>%
  rename(year=YEAR)#rename to get characters the same for merge

#add cpi data to account for real minimum wage
base_2023 <- cpi2 %>% filter(year == 2023) %>% pull(cpi_u) #2023 will serve as base year

min_wage_long <- min_wage_long %>%
  left_join(cpi2, by = "year") %>%
  mutate(min_wage_real = min_wage * (base_2023/cpi_u))
```


```{r}
gdp_income_long <- gdp_income %>%
  rename_with(~str_remove(., "^X"), starts_with("X")) %>%
  filter(LineCode %in% c(1, 8)) %>%
  select(GeoName, GeoFips, LineCode, all_of(as.character(2010:2023))) %>%
  pivot_longer(
    cols = all_of(as.character(2010:2023)),
    names_to = "YEAR",
    values_to = "value"
  ) %>%
  mutate(
    YEAR = as.integer(YEAR), 
    value = parse_number(as.character(value)),
    STATEFIP = as.integer(parse_number(as.character(GeoFips)) / 1000L), 
    var = case_when(
      LineCode == 1 ~ "real_gdp", 
      LineCode == 8 ~ "real_per_capita_income"
    )
  ) %>%
  filter(STATEFIP >0 & STATEFIP != 11) %>%
  select(STATEFIP, YEAR, var, value, GeoName) %>%
  pivot_wider(names_from = var, values_from = value) %>%
  mutate(real_gdp = as.numeric(real_gdp), 
         real_per_capita_income = as.numeric(real_per_capita_income)
         ) 
```

```{r}
unemployment_with_fips <- unemployment_rate_data %>%
  left_join(
    min_wage_long %>%
      distinct(state, StateFIPS) %>%
      transmute(state, STATEFIP = as.integer(StateFIPS)), 
    by = "state"
  ) %>%
  transmute(STATEFIP, year, annual_unemp_sa, state)
```


```{r}
#filter out years within unemployment_with_fips
unemployment_with_fips <- unemployment_with_fips %>%
  filter(year > 2009 & year < 2024)

#rename columns for lowercase match
ipums_poverty <- ipums_poverty %>%
  rename(year=YEAR)
gdp_income_long <- gdp_income_long %>%
  rename(year=YEAR)
```

```{r}
#merging datasets
panel_data <- ipums_poverty %>%
  left_join(min_wage_long %>% transmute(STATEFIP = as.integer(StateFIPS), year, min_wage, min_wage_real), 
            by = c("STATEFIP", "year")) %>%
  left_join(unemployment_with_fips, by = c("STATEFIP", "year")) %>%
  left_join(gdp_income_long, by = c("STATEFIP", "year"))


#filter out district of columbia
panel_clean <- panel_data %>%
  filter(STATEFIP != 11)

#summary of data
summary(panel_clean)
names(panel_clean)


```



```{r}
#check data distributions

#gdp 
ggplot(panel_clean, aes(x = real_gdp)) + geom_histogram(bins = 30, fill = "darkgreen", color = "black") + labs(title = "Distribution of GDP")

#income
ggplot(panel_clean, aes(x = real_per_capita_income)) + geom_histogram(bins = 30, fill = "darkblue", color = "white") + labs(title = "Distribution of Real Per Capita Income")

#minimum wage 
ggplot(panel_clean, aes(x = min_wage_real)) + geom_histogram(bins = 30, fill = "darkred", color = "white") + labs(title = "Distribution of Minimum Wage Across States")


#due to skewness of variables and common practice in research, some log transformations will be applied

#also creating dummy variable and log of one that looks okay distribution wise, but can be used down the line for robustness check
panel_clean2 <- panel_clean %>%
  mutate(log_gdp = log(pmax(real_gdp, 1)), 
         log_income = log(pmax(real_per_capita_income, 1)), 
         log_minw_real = log(pmax(min_wage_real, 1)), 
         treated_minw = as.integer(min_wage > 7.25))
  

#based on the scaling for poverty_rate, converting to a percent scale makes sense for ease of interpretability. 
panel_clean2 <- panel_clean2 %>%
  mutate(poverty_rate_pct = poverty_rate * 100, 
         STATEFIP = as.integer(STATEFIP), 
         year = as.integer(year))
```

```{r}
plot_data <- panel_clean2 %>%
  group_by(STATEFIP) %>%
  mutate(Group = ifelse(any(min_wage > 7.25), "Treated", "Control")) %>%
  ungroup()


ggplot(plot_data, aes(x = as.numeric(as.character(year)), y = poverty_rate_pct, color = Group)) + 
  stat_summary(fun = "mean", geom = "line", size = 1.2) + 
  stat_summary(fun = "mean", geom = "point", size = 2.5) + 
  labs(title = "Parallel Trends Check: Treated vs. Control States",
       subtitle = "Average poverty rates before and after minimum wage increases",
       x = "Year", y = "Mean Povery Rate", color = "Group") + 
  theme_minimal()

ggsave(filename = "parallel_trend_plot.png", dpi = 300)
```

The parallel trends plot compares the pre-treatment trajectories of mean poverty rates between states that enacted minimum wage increases (treated group) and those that did not ("control"). Prior to 2014, both groups follow roughly similar paths, with some variation around 2012 to 2014. Post-2014, both groups follow roughly similar paths, treated states exhibit a slightly higher level but maintain a broadly parallel movement, suggesting no sharp divergence in pre-trends. This visual evidence mostly supports the plausibility of parallel trends assumption required for difference-in-differences estimation, while indicating potential heterogeneity in post-treatment responses. 

```{r}
ggplot(panel_clean2, aes(x = poverty_rate_pct)) + geom_histogram(bins = 30, fill = "blue", color = "black") + labs(title = "Distribution of State-Year Poverty Rates")

```

```{r}
#poverty vs minimum wage
ggplot(panel_clean2, aes(x = log_minw_real, y = poverty_rate_pct)) + 
  geom_point(alpha = 0.6, color = "blue") + 
  geom_smooth(method = "lm", se = FALSE, color = "red", size = 1) + 
  labs(title = "Poverty vs. Minimum Wage", 
       x = "Log(Minimum Wage)", 
       y = "Poverty Rate") + theme_slide
```

The scatterplot shows a negative relationship between poverty rates and real per capita income across states and years. As income levels rise, poverty rates consistently decline, which aligns with economic theory that higher income improves household well-being and reduces the share of individuals living below the poverty threshold. The fitted regression line highlights a moderately strong downward slope, suggesting that even small proportional increases in per capita income are associated with measurable reductions in state-level poverty. This relationship provides early support for including real per capita income as a key control variable in assessing the effects of minimum wage policy on poverty.


```{r}
#poverty vs. income
ggplot(panel_clean2, aes(x = log_income, y = poverty_rate_pct)) +
  geom_point(alpha = 0.6, color = "black") + geom_smooth(method = "lm", se = FALSE, color = "orange", size = 1) + 
  labs(title = "Poverty (Percentage Points) vs Real Per Capita Income", x = "Log(Income)", y = "Poverty Rate") + theme_slide

ggsave(filename = "log_income_vs_poverty_rate.png", dpi = 400)
```

The relationship visualized between poverty rates and the log of minimum wage was also negative. though somewhat weaker and more dispersed than that observed for income. States with higher minimum wages generally exhibit lower poverty rates, but the wider scatter reflects that wage policy alone does not fully explain poverty variation across states. Still, the downward-sloping trend line indicates that increases in the minimum wage are correlated with lower poverty, supporting the hypothesis that higher wage floors can improve living standards for low-income workers. The visualization provides early evidence of the expected direction of the policy's impact. which will be tested more formally in the fixed-effects regressions. 

```{r}
panel_clean2 %>%
  group_by(treated_minw) %>%
  summarise(
    mean_poverty = mean(poverty_rate_pct, na.rm = T),
    mean_minw = mean(min_wage, na.rm = T),
    mean_income = mean(real_per_capita_income, na.rm = T),
    mean_unemp = mean(annual_unemp_sa, na.rm = T)
  )
```


```{r}
str(panel_clean2)
names(panel_clean2)


fe_model <- feols(
  poverty_rate_pct ~ log_minw_real | STATEFIP + year,
  data = panel_clean2,
  cluster = ~ STATEFIP,
  weights = ~ pop_weight,
)

summary(fe_model)


```

The two-way fixed effects output above, estimated with state and year fixed effects and population weights, revealed no statistically significant association between real minimum wage and state-level poverty rates among full-time low-wage workers. Although the coefficient on the log of minimum wage was positive, its large standard error indicates substantial uncertainty, and the overall within-state explanatory power of the model was minimal (within R2 of 0.007). These findings suggest that contemporaneous fixed effect estimates may obscure heterogeneous or lagged treatment effects, particularly in the context of staggered state-level minimum wage increases. Consequently, the next stage of analysis employs the staggered difference-in-differences framework proposed by Callaway & Sant'Anna (2021) to identify dynamic and heterogeneous policy effects over time. 

```{r}
coef_data <- tidy(fe_model, conf.int = T)

coef_data %>%
  filter(term == "log_minw_real") %>%
  ggplot(aes(x = term, y = estimate)) + 
  geom_point(color = "darkred", size = 3) + 
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2, color = "gray40") + 
  labs(title = "Effect of Log (Minimum Wage) on Poverty Rate", 
       x = "", y = "Estimated Coefficient") + theme_minimal()
``` 

The coefficient plot displays the estimated relationship between the log of minimum wage and the state-level poverty rate from the fixed effects regression. The red dot represents the point estimate, while the gray vertical line shows the 95% confidence interval. The estimate of approximately -0.012 indicates that, while holding constant real per capita income, real GDP, and unemployment, a 1% increase in the minimum wage is associated with roughly a 0.012 percentage point decrease in the poverty rate. Although the direction is negative

```{r}
coef_keep <- c("log_minw_real", "log_income", "log_gdp", "annual_unemp_sa")

coef_df <- tidy(fe_model, conf.int = T) %>%
  filter(term %in% coef_keep) %>%
  mutate(term = factor(term, 
                       levels = rev(coef_keep), 
                       labels = rev(c("Log (Min Wage)", "Log (Income Per Capita)", "Log (Real GDP)", "Unemployment Rate"))))

p_coef <- ggplot(coef_df, aes(x = term, y = estimate)) + 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high), size = 0.8) + 
  coord_flip() + labs(
    title = "Fixed Effects Model Coefficients", 
    subtitle = "State & Year FE; clustered by state; pop-weighted", 
    x = NULL, 
    y = "Estimated effect on poverty rate (pp)"
  ) + theme_slide

ggplot(coef_df, aes(x = term, y = estimate)) + 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high), size = 0.8) + 
  coord_flip() + labs(
    title = "Fixed Effects Model Coefficients", 
    subtitle = "State & Year FE; clustered by state; pop-weighted", 
    x = NULL, 
    y = "Estimated effect on poverty rate (pp)"
  ) + theme_slide

ggsave(filename = "Fixed_effects_coef_plot.png", dpi = 300)
```

#Covariate Extraction
```{r}
#additional covariates
ipums_covariates <- ipums %>%
  filter( #original poverty sample restriction
    GQ %in% c(1,2), 
    EMPSTAT == 1, 
    UHRSWORK >= 35,
    WKSWORK2 >= 6,
    AGE >= 18, AGE <= 64
  ) %>%
  mutate(
    POVERY = as.numeric(POVERTY), 
    low_wage = if_else(POVERTY <= 150, 1L, 0L, missing = NA_integer_)
  ) %>%
  filter(low_wage == 1) %>%
  group_by(STATEFIP, YEAR) %>%
  summarise(
    med_income = Hmisc::wtd.quantile(INCWAGE, weights = PERWT, probs = 0.5),
    
    #demographic composition
    share_lowedu = weighted.mean(EDUC <= 5, w = PERWT, na.rm = T),
    share_nonwhite = weighted.mean(RACE != 1, w = PERWT, na.rm = T),
    share_under30 = weighted.mean(AGE < 30, w = PERWT, na.rm = T),
    
    #assistance measures
    share_foodstmp = weighted.mean(FOODSTMP == 2, w = PERWT, na.rm = T),
    
    .groups = "drop"
  ) %>%
  mutate(STATEFIP = as.integer(STATEFIP)) %>%
  filter(STATEFIP != 11)
```


```{r}
#identify treatment timing
#reflects each state's first year of a minimum-wage increase above baseline
panel_clean2 <- panel_clean2 %>%
  mutate(binding_nominal = min_wage > 7.25)
class(panel_clean2$STATEFIP)
class(ipums_covariates$STATEFIP)

panel_clean2 <- panel_clean2 %>%
  mutate(
    STATEFIP = as.integer(STATEFIP),
    year     = as.integer(year)
  )

ipums_covariates <- ipums_covariates %>%
  mutate(
    STATEFIP = as.integer(as.character(STATEFIP)),  
    YEAR     = as.integer(YEAR)
  )

panel_clean2 <- panel_clean2 %>%
  left_join(ipums_covariates %>% rename(year = YEAR), 
            by = c("STATEFIP", "year"))

#classification of states
by_state <- panel_clean2 %>%
  group_by(STATEFIP, state) %>%
  arrange(year, .by_group = T) %>%
  mutate(
    delta_mw = min_wage - lag(min_wage), 
    inc_any  = !is.na(delta_mw) & delta_mw > 0,
    inc_50   = !is.na(delta_mw) & delta_mw >= 0.50,
    inc_100  = !is.na(delta_mw) & delta_mw >= 1.00
  ) %>%
  summarise(ever_treated_any = any(inc_any, na.rm = T), 
            first_treat_any = if (ever_treated_any) min(year[inc_any], na.rm = T) else 0L, 
            
            ever_treated_50 = any(inc_50, na.rm = T), 
            first_treat_50 = if (ever_treated_50) min(year[inc_50], na.rm = T) else 0L, 
            
            ever_treated_100 = any(inc_100, na.rm = T), 
            first_treat_100 = if (ever_treated_100) min(year[inc_100], na.rm = T) else 0L, 
            .groups = "drop"
            ) %>%
  mutate(
    group_any = ifelse(ever_treated_any, "adopter", "never"), 
    first_treat_any = ifelse(group_any == "never", 0L, first_treat_any),
    first_treat_any = as.integer(first_treat_any),

    first_treat_50  = ifelse(ever_treated_50  == FALSE, 0L, first_treat_50),
    first_treat_50  = as.integer(first_treat_50),

    first_treat_100 = ifelse(ever_treated_100 == FALSE, 0L, first_treat_100),
    first_treat_100 = as.integer(first_treat_100)
  )

panel_clean2 <- panel_clean2 %>%
  left_join(by_state %>% select(STATEFIP, first_treat_any, first_treat_50, first_treat_100, group_any),
            by = "STATEFIP") %>%
    mutate(
    treated_any  = as.integer(first_treat_any > 0L & year >= first_treat_any),
    treated_50   = as.integer(first_treat_50  > 0L & year >= first_treat_50),
    treated_100  = as.integer(first_treat_100 > 0L & year >= first_treat_100)
  )

summary(panel_clean2)
```



```{r}
#filter for staggered did
class(by_state$STATEFIP)
str(panel_clean2)

stag_did <- panel_clean2 %>%
  filter(group_any %in% c("adopter","never")) %>%
  mutate(STATEFIPS = as.integer(STATEFIP)) 

stag_did_fe <- stag_did

cohort_sizes <- stag_did %>%
  distinct(STATEFIPS, first_treat_any) %>%
  filter(first_treat_any != 0) %>%
  count(first_treat_any, name = "n_states") %>%
  arrange(first_treat_any)

valid_cohorts <- cohort_sizes %>% filter(n_states >= 4) %>% pull(first_treat_any)

stag_est <- stag_did %>%
  filter(first_treat_any %in% valid_cohorts | first_treat_any == 0L)

```



Going forward, the staggered DiD estimator requires adequate overlap and enough treated units within each adoption cohort to provide sable group-time effects. The cohort table provided above shows that several early and late adoption cohorts contain very few adopting states (i.e. 2011, 2012, 2021). To avoid weak identification, good prediction in the propensity step, and convergence/overlap failures, I intend to follow standard practice an exclude cohorts that are low in numbers.


```{r}
stag_est_win <- stag_est %>%
  mutate(z_med_income = scale(med_income)[,1],
         z_unemp = scale(annual_unemp_sa)[,1],
         z_snap = scale(share_foodstmp)[,1],
         z_share_lowedu = scale(share_lowedu)[,1],
         z_share_nonwhite = scale(share_nonwhite)[,1],
         z_share_under30 = scale(share_under30)[,1],
         poverty_rate_pct = as.numeric(poverty_rate_pct)
         ) %>%
  drop_na(poverty_rate_pct, z_med_income, z_snap, z_share_lowedu, z_share_nonwhite, z_share_under30, z_unemp)

summary(stag_est_win)

#do the same thing above for fixed effects dataset. Only different as I am excluding cohorts in the stag_est_win that are less than 3 observations.
stag_did_fe <- stag_did_fe %>%
  mutate(z_med_income = scale(med_income)[,1],
         z_unemp = scale(annual_unemp_sa)[,1],
         z_snap = scale(share_foodstmp)[,1],
         z_share_lowedu = scale(share_lowedu)[,1],
         z_share_nonwhite = scale(share_nonwhite)[,1],
         z_share_under30 = scale(share_under30)[,1],
         poverty_rate_pct = as.numeric(poverty_rate_pct)
         ) %>%
  drop_na(poverty_rate_pct, z_med_income, z_snap, z_share_lowedu, z_share_nonwhite, z_share_under30, z_unemp)
  
```




```{r}
#FE with covariates
#came back to this after DiD results yielded little significance
#I want to now know, are states with binding minimum wages and stronger safety nets systematically different in poverty outcomes?
fe_model <- feols(
  poverty_rate_pct ~ log_minw_real + z_share_lowedu + z_unemp + z_snap + z_share_nonwhite | STATEFIP + year,
  data = stag_did_fe,
  cluster = ~ STATEFIPS,
  weights = ~ pop_weight,
)

summary(fe_model)

#polished results of fixed effects regression
etable(fe_model, digits = 3, title = "Fixed Effects Model: Poverty vs. Minimum Wage with Covariates")
```

```{r}
#define event window
stag_est_win <- stag_est_win %>%
  mutate(event_time = if_else(first_treat_any == 0L, NA_integer_, year - first_treat_any)) 
```


```{r}
#Timing of First minimum wage increases above 7.25 by year
by_state %>%
  filter(!STATEFIP %in% first_treat_any, !is.na(first_treat_any)) %>%
  ggplot(aes(x = as.factor(first_treat_any))) + 
  geom_bar(fill = "blue") + 
  labs(
    title = "Timing of First Minimum Wage Increases Above $7.25",
    x = "First Treatment Year", 
    y = "Number of States"
  ) + theme_minimal(base_size = 13)
```




```{r}
stag_est <- stag_est %>%
  mutate(STATEFIPS = as.integer(STATEFIP)) #new state identifier
att <- att_gt(
  yname = "poverty_rate_pct", 
  tname = "year", 
  idname = "STATEFIPS",
  gname = "first_treat_any",
  data = stag_est, 
  panel = T, 
  control_group = "nevertreated",
  clustervars = "STATEFIPS",
  bstrap = T,
  biters = 500
)

agg_overall <- aggte(att, type = "group") #overall att
agg_dyn <- aggte(att, type = "dynamic") #event-study
summary(agg_overall)
```



```{r}
summary(agg_dyn)
```




```{r}
prepost_ok <- stag_est_win %>%
  filter(first_treat_any != 0L) %>%
  group_by(STATEFIPS, first_treat_any) %>%
  summarise(
    has_pre  = any(year <  first_treat_any),
    has_post = any(year >= first_treat_any),
    .groups = "drop"
  ) %>%
  filter(has_pre & has_post) %>%
  pull(STATEFIPS)

stag_est_win <- stag_est_win %>%
  filter(first_treat_any == 0L | STATEFIPS %in% prepost_ok)

stag_est_win %>% filter(first_treat_any != 0L) %>%
  summarise(any_pre = any(event_time < 0, na.rm = TRUE),
            any_post = any(event_time >= 0, na.rm = TRUE))
summary(stag_est_win)
table(stag_est_win$first_treat_any)
```


```{r}
#number of states each year that increased
stag_est_win %>%
  group_by(first_treat_any) %>%
  summarise(n_states = n_distinct(STATEFIPS), .groups = "drop")
```

```{r}
#check correlations of covariates as I was having errors trying to include all of them
covars <- stag_est_win %>%
  select(z_med_income, z_snap, z_share_lowedu, z_share_nonwhite, z_share_under30, annual_unemp_sa, poverty_rate_pct)

round(cor(covars, use = "pairwise.complete.obs"), 2)
```


```{r}
att_cov_nyt <- att_gt(
  yname = "poverty_rate_pct",
  tname = "year",
  idname = "STATEFIPS",
  gname = "first_treat_any",
  xformla = ~ z_share_lowedu + z_unemp + z_snap + z_share_nonwhite,
  data = stag_est_win,
  panel = F,
  control_group = "notyettreated",
  clustervars = "STATEFIPS",
  bstrap = T,
  biters = 500
)


agg_overall_cov <- aggte(att_cov_nyt, type = "group",   na.rm = TRUE)
agg_dynamic_cov <- aggte(att_cov_nyt, type = "dynamic", na.rm = TRUE)

summary(agg_overall_cov)
summary(agg_dynamic_cov)
```
 
 
 
 
 
```{r}
#I want to now know, are states with binding minimum wages and stronger safety nets systematically different in poverty outcomes?
#expanding on the one from before, now looking at lags 
stag_did_fe2 <- stag_did_fe %>%
  group_by(STATEFIP) %>%
  arrange(year) %>%
  mutate(
    minw_lag1 = lag(log_minw_real, 1),
    minw_lag2 = lag(log_minw_real, 2)
         ) %>%
  ungroup()
  
fe_lag <- feols(
  poverty_rate_pct ~ minw_lag1 + minw_lag2 + z_share_lowedu + z_unemp + z_snap + z_share_nonwhite | STATEFIPS + year,
  data = stag_did_fe2,
  cluster = ~ STATEFIPS,
  weights = ~ pop_weight,
)

summary(fe_lag)
etable(fe_lag)
```



```{r}
#fixed effects including state-specific linear time trends
fe_trend <- feols(
  poverty_rate_pct ~ log_minw_real + z_unemp + z_share_lowedu + z_share_nonwhite + z_share_under30 + z_snap
  | STATEFIPS + year + STATEFIPS[year],
  data = stag_did_fe2,
  weights = ~ pop_weight,
  cluster = ~ STATEFIPS
)
etable(fe_model, fe_trend)

```

```{r}
#fixed effects excluding covid years
fe_nopand <- feols(
  poverty_rate_pct ~ log_minw_real + z_unemp + z_share_lowedu + z_share_nonwhite + z_share_under30 + z_snap
  | STATEFIPS + year,
  data = stag_did_fe2 %>% filter(!(year %in% c(2020, 2021))),
  weights = ~ pop_weight,
  cluster = ~ STATEFIPS
)
etable(fe_model, fe_nopand)

```

 
```{r}
p_dyn <- ggdid(agg_dynamic_cov) +
  labs(
    title    = "Event Study: Minimum Wage and Poverty",
    subtitle = "Callaway & Sant’Anna staggered DID (with controls)",
    x = "Years since first increase",
    y = "ATT (percentage points)"
  ) +
  theme_minimal(base_size = 14)

print(p_dyn)
```
 
#Robustness checks
 
```{r}
#changing control group; results should be roughly the same
att_cov_never <- att_gt(
  yname = "poverty_rate_pct",
  tname = "year",
  idname = "STATEFIPS",
  gname = "first_treat_any",
  xformla = ~ z_share_lowedu + z_unemp + z_snap + z_share_nonwhite,
  data = stag_est_win,
  panel = F,
  control_group = "nevertreated",
  clustervars = "STATEFIPS", 
  bstrap = T,
  biters = 500
)

agg_dyn_never <- aggte(att_cov_never, type = "dynamic", na.rm = T)
summary(agg_dyn_never)
```
 
Comparing the results from this difference-in-differences output which changes the control group to never-treated to the results of the difference-in-differences with not yet treated observations reveal similar results, which indicates findings are robust.


#Section for polishing current graphs
```{r}
custom_theme <- theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 10),
    plot.caption = element_text(size = 8, hjust = 0),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_blank()
  )
```

```{r}
fig1 <- ggplot(panel_clean2, aes(x = log_minw_real, y = poverty_rate_pct)) +
  geom_point(color = "steelblue", alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(
    title = "Figure 1: Poverty vs Log(Minimum Wage)",
    subtitle = "State-year observations for full-time low-wage workers (2010–2023)",
    x = "Log(Minimum Wage, real 2023 dollars)",
    y = "Poverty Rate (%)",
    caption = "Notes: Each point represents a state-year. The red line is a linear fit."
  ) +
  custom_theme

ggsave("fig1_poverty_vs_log_minwage.png", fig1, width = 6, height = 4.5, dpi = 300)

```

```{r}
fig2 <- ggplot(panel_clean2, aes(x = log_income, y = poverty_rate_pct)) +
  geom_point(color = "darkgray", alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE, color = "orange") +
  labs(
    title = "Figure 2: Poverty vs Log(Real Per Capita Income)",
    subtitle = "State-year observations for full-time low-wage workers (2010–2023)",
    x = "Log(Real Per Capita Income, 2023 dollars)",
    y = "Poverty Rate (%)",
    caption = "Notes: Each point represents a state-year. The orange line is a linear fit."
  ) +
  custom_theme

ggsave("fig2_poverty_vs_log_income.png", fig2, width = 6, height = 4.5, dpi = 300)

```

```{r}
fig3 <- ggplot(plot_data, aes(x = as.numeric(as.character(year)), y = poverty_rate_pct, color = Group)) +
  stat_summary(fun = "mean", geom = "line", size = 1.2) + 
  stat_summary(fun = "mean", geom = "point", size = 2.5) +
  scale_color_manual(values = c(
    "Control" = "gray50", 
    "Treated" = "red1"
  )) + 
  labs(
    x = "Year",
    y = "Mean Poverty Rate (%)") +
  custom_theme +
  theme(legend.position = "bottom")
print(fig3)
ggsave("fig3_parallel_trends.png", fig3, width = 6.5, height = 4.5, dpi = 600)

```





```{r}

fig4 <- by_state %>%
  filter(!STATEFIP %in% first_treat_any, !is.na(first_treat_any)) %>%
  ggplot(aes(x = as.factor(first_treat_any))) +
  geom_bar(fill = "blue") +
  labs(
    title = "Figure 4: Timing of First Minimum Wage Increases",
    subtitle = "States that never increased above $7.25 are coded as 0",
    x = "First Treatment Year",
    y = "Number of States",
    caption = "Notes: The treatment year is the first year a state’s minimum wage exceeded $7.25 during 2010–2023."
  ) +
  custom_theme
ggsave("fig4_first_treat_histogram.png", fig4, width = 6, height = 4.5, dpi = 300)
```


```{r}
es_df <- data.frame(
  egt   = agg_dynamic_cov$egt,
  att   = agg_dynamic_cov$att.egt,
  se    = agg_dynamic_cov$se.egt
) %>%
  mutate(
    period = ifelse(egt < 0, "Pre", "Post"),
    crit   = as.numeric(agg_dynamic_cov$crit.val.egt[1]),  
    ci_low  = att - crit * se,
    ci_high = att + crit * se
  )
#Figure 1: Event Study – Minimum Wage → Poverty
p_es_noline <- ggplot(es_df, aes(x = egt, y = att)) +
  geom_hline(
    yintercept = 0,
    linetype = "dashed",
    color = "gray55",
    linewidth = 0.7
  ) +
  geom_linerange(
    aes(ymin = ci_low, ymax = ci_high),
    color = "gray50",
    linewidth = 0.6
  ) +
  geom_point(
    aes(color = period),
    size = 2.6
  ) +
  scale_color_manual(values = c("Pre" = "green4", "Post" = "red3")) +
  labs(
    x        = "Years since first increase",
    y        = "Average Treatment Effect on the Treated"
  ) +
  
  theme_minimal(base_size = 14) +
  theme(
    legend.position  = "none",
    panel.grid.minor = element_blank(),
    axis.title       = element_text(face = "bold"),
    plot.title       = element_text(face = "bold")
  )

print(p_es_noline)
ggsave("event_study_points_only_pre_green_post_red.png", p_es_noline,
       width = 10, height = 6, dpi = 600)
```





```{r}
p_exp <- ggdid(agg_dynamic_cov) +
  labs(
    title    = "Figure 2: Average Effect by Length of Exposure ",
    subtitle = "Estimated change in poverty among full-time low-wage workers by years since \nfirst state minimum wage increase (with controls)",
    x        = "Years since first minimum wage increase",
    y        = "Estimated change in poverty rate (percentage points)",
    caption  = "Each point shows how poverty among full time low wage workers changed in states that raised their minimum wage, compared with states \nthat never did. Values to the left of zero represent years before the first increase and remain close to zero, which suggests that \nstates followed similar trends before the policy took effect. Beginning at year zero, when the minimum wage increases, the \nestimates become progressively more negative, showing that poverty declines over time. By two to five years after the increase, \nstates display sizable reductions in poverty for full time low wage workers. Vertical bars represent 95 percent confidence intervals."
  ) +
  custom_theme


# Save high-res
ggsave("fig2_avg_effect_exposure.png", p_exp, width = 7, height = 5, dpi = 300)

print(p_exp)
```

```{r}
modelsummary::msummary(
  list("Fixed Effects Model" = fe_model),
  title   = "Table 1. Fixed Effects Model: Poverty vs. Minimum Wage",
  gof_map = c("nobs", "r.squared"),
  stars   = TRUE,
  notes   = "Notes: State and year fixed effects; population weights applied; SEs clustered by state.",
  output  = "Table1_FE.docx"        # <-- exported DOCX
)


```

```{r}
agg_group   <- aggte(att, type = "group")
agg_dynamic <- aggte(att, type = "dynamic")

table2_df <- bind_rows(
  tibble(
    Row = "Overall ATT (Group aggregation)",
    ATT_pp = as.numeric(agg_group$overall.att),
    Std_Error = as.numeric(agg_group$overall.se)
  ),
  tibble(
    Row = "Overall ATT (Dynamic aggregation)",
    ATT_pp = as.numeric(agg_dynamic$overall.att),
    Std_Error = as.numeric(agg_dynamic$overall.se)
  ),
  tibble(
    Row = paste0("Cohort ", agg_group$egt),
    ATT_pp = as.numeric(agg_group$att.egt),
    Std_Error = as.numeric(agg_group$se.egt)
  )
) |>
  mutate(
    CI_Lower_95 = ATT_pp - 1.96 * Std_Error,
    CI_Upper_95 = ATT_pp + 1.96 * Std_Error
  ) |>
  mutate(across(c(ATT_pp, Std_Error, CI_Lower_95, CI_Upper_95), ~round(., 2)))

#one-line export via modelsummary
modelsummary::datasummary_df(
  table2_df,
  title  = "Table 2. Aggregated and Cohort-Specific ATT Estimates",
  notes  = "Notes: Cluster-robust SEs by state. 'Overall (group)' and 'Overall (dynamic)' are from aggte(..., type='group'/'dynamic').",
  output = "Table2_ATT.docx"   
)
```



```{r}
agg_group2   <- aggte(att_cov_nyt, type = "group", na.rm = T)
agg_dynamic2 <- aggte(att_cov_nyt, type = "dynamic", na.rm = T)

table3_df <- bind_rows(
  tibble(
    Row = "Overall ATT (Group aggregation)",
    ATT_pp = as.numeric(agg_group2$overall.att),
    Std_Error = as.numeric(agg_group2$overall.se)
  ),
  tibble(
    Row = "Overall ATT (Dynamic aggregation)",
    ATT_pp = as.numeric(agg_dynamic2$overall.att),
    Std_Error = as.numeric(agg_dynamic2$overall.se)
  ),
  tibble(
    Row = paste0("Cohort ", agg_group2$egt),
    ATT_pp = as.numeric(agg_group2$att.egt),
    Std_Error = as.numeric(agg_group2$se.egt)
  )
) |>
  mutate(
    CI_Lower_95 = ATT_pp - 1.96 * Std_Error,
    CI_Upper_95 = ATT_pp + 1.96 * Std_Error
  ) |>
  mutate(across(c(ATT_pp, Std_Error, CI_Lower_95, CI_Upper_95), ~round(., 2)))

#one-line export via modelsummary
modelsummary::datasummary_df(
  table3_df,
  title  = "Table 3. Aggregated and Cohort-Specific ATT Estimates with Controls",
  notes  = "Notes: Cluster-robust SEs by state. 'Overall (group)' and 'Overall (dynamic)' are from aggte(..., type='group'/'dynamic').",
  output = "Table3_ATT.docx"   
)
```

```{r}
#table construction for fixed effects outputs
models <- list(
  "TWFE + Covariates" = fe_model,
  "TWFE + State Trends" = fe_trend
)

coef_map <- c(
  "log_minw_real"    = "Log real minimum wage",
  "z_share_lowedu"   = "Low education share (z)",
  "z_unemp"          = "Unemployment rate (z)",
  "z_snap"           = "SNAP participation (z)",
  "z_share_nonwhite" = "Nonwhite share (z)"
)

gof_map <- data.frame(
  raw = c("nobs", "FE: STATEFIP", "FE: year"),
  clean = c("Observations", "State FE", "Year FE"),
  fmt = c(0, 0, 0)
)

modelsummary::msummary(
  models,
  coef_map = coef_map,
  statistic = "({std.error})",
  stars = TRUE,
  fmt = 3,
  gof_map = gof_map,
  notes = "Population-weighted. Standard errors (in parentheses) clustered by state.", 
  output = "fe_table_poster.docx"
)
```


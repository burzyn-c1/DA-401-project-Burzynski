---
title: "DA 401 Early Results"
author: "Calvin Burzynski"
date: "2025-10-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(dplyr)
library(tidyr)
library(stringr)
library(lubridate)
library(readr)
library(ggplot2)
library(fixest)
library(janitor)
library(broom)
library(data.table)
library(did)

#load in ipums (acs) dataset
ipums <- fread("../../../usa_00005.csv.gz") #used fread from the data.table package as the file is large and this allowed it to be loaded in much quicker

#load minimum wage DOL data
min_wage_data <- fread("..//../..//Minimum Wage from DOL 2010-2023.csv") #used fread to avoid X in front of year column names

#load monthly unemployment rate data
unemployment_rate_data <- read.csv("..//..//..//state_unemploy_panel_copy_paste.csv")

gdp_income <- read.csv("..//..//..//State Annual Summary Statistics GDP Income.csv", skip = 3)

cpi <- read_csv("../../../CPI_all_urban_import.csv") #got warning but data loaded in just fine

tail(ipums)
```
```{r}
#clean cpi a bit
cpi2 <- cpi %>%
  rename(year=Year) %>%
  transmute(
    year = as.integer(year), 
    cpi_u = as.numeric(Annual)
  ) 
```


```{r}
#reusable visual theme for graphs 
theme_slide <- theme_minimal(base_size = 13) + 
  theme(
    plot.title.position = "plot",
    plot.title = element_text(face = "bold"), 
    plot.subtitle = element_text(margin = margin(b = 10)), 
    plot.caption = element_text(size = 9, color = "grey40"), 
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    axis.title.y = element_text(margin = margin(r = 8)),
    axis.title.x = element_text(margin = margin(t = 8)),
    legend.position = "bottom"
  )
```


```{r}
#filter for poverty status
ipums %>%
  distinct(POVERTY) %>%
  arrange(POVERTY) #investigating values of poverty 
summary(ipums$POVERTY)
summary(ipums$EMPSTAT)

```


```{r}
ipums_poverty <- ipums %>%
  filter(EMPSTAT == 1, UHRSWORK >= 35, WKSWORK2 >= 6, AGE >= 18, AGE <= 64) %>%
  mutate(POVERTY = as.numeric(POVERTY)) %>%
  mutate(in_poverty = case_when(
    is.na(POVERTY) ~ NA_real_,
    POVERTY < 100 ~ 1, 
    POVERTY >= 100 ~ 0
  ), 
    low_wage = if_else(POVERTY <= 150, 1L, 0L, missing = NA_integer_) #using 150 as the cutoff as most analyses go beyond strict poverty to include near-poor population. Many federal programs use 125 to 150% and my analysis focuses on poverty or near poverty populations
  ) %>%
  filter(low_wage == 1) %>%
  group_by(STATEFIP, YEAR) %>%
  summarise(
    poverty_rate = weighted.mean(in_poverty, w = PERWT, na.rm = T), 
    pop_weight = sum(PERWT, na.rm = T), 
    .groups = "drop"
  )
#pop_weight represents the estimated total number of individuals represented by the ACS sample in that state-year 
```


```{r}
min_wage_long <- min_wage_data %>%
  rename_with(~str_remove(., "^X"), starts_with("X")) %>% #cleans columns with 'X' prefix
  pivot_longer(
    cols = all_of(as.character(2010:2023)),
    names_to = "YEAR",
    values_to = "min_wage"
  ) %>%
  mutate(
    YEAR = as.numeric(YEAR)
  ) %>%
  filter(between(YEAR, 2010, 2023))

min_wage_long <- min_wage_long %>%
  rename(state=State) %>%
  rename(year=YEAR)#rename to get characters the same for merge

#add cpi data to account for real minimum wage
base_2023 <- cpi2 %>% filter(year == 2023) %>% pull(cpi_u) #2023 will serve as base year

min_wage_long <- min_wage_long %>%
  left_join(cpi2, by = "year") %>%
  mutate(min_wage_real = min_wage * (base_2023/cpi_u))
```


```{r}
gdp_income_long <- gdp_income %>%
  rename_with(~str_remove(., "^X"), starts_with("X")) %>%
  filter(LineCode %in% c(1, 8)) %>%
  select(GeoName, GeoFips, LineCode, all_of(as.character(2010:2023))) %>%
  pivot_longer(
    cols = all_of(as.character(2010:2023)),
    names_to = "YEAR",
    values_to = "value"
  ) %>%
  mutate(
    YEAR = as.integer(YEAR), 
    value = parse_number(as.character(value)),
    STATEFIP = as.integer(parse_number(as.character(GeoFips)) / 1000L), 
    var = case_when(
      LineCode == 1 ~ "real_gdp", 
      LineCode == 8 ~ "real_per_capita_income"
    )
  ) %>%
  filter(STATEFIP >0 & STATEFIP != 11) %>%
  select(STATEFIP, YEAR, var, value, GeoName) %>%
  pivot_wider(names_from = var, values_from = value) %>%
  mutate(real_gdp = as.numeric(real_gdp), 
         real_per_capita_income = as.numeric(real_per_capita_income)
         ) 
```

```{r}
unemployment_with_fips <- unemployment_rate_data %>%
  left_join(
    min_wage_long %>%
      distinct(state, StateFIPS) %>%
      transmute(state, STATEFIP = as.integer(StateFIPS)), 
    by = "state"
  ) %>%
  transmute(STATEFIP, year, annual_unemp_sa, state)
```


```{r}
#filter out years within unemployment_with_fips
unemployment_with_fips <- unemployment_with_fips %>%
  filter(year > 2009 & year < 2024)

#rename columns for lowercase match
ipums_poverty <- ipums_poverty %>%
  rename(year=YEAR)
gdp_income_long <- gdp_income_long %>%
  rename(year=YEAR)
```

```{r}
#merging datasets
panel_data <- ipums_poverty %>%
  left_join(min_wage_long %>% transmute(STATEFIP = as.integer(StateFIPS), year, min_wage, min_wage_real), 
            by = c("STATEFIP", "year")) %>%
  left_join(unemployment_with_fips, by = c("STATEFIP", "year")) %>%
  left_join(gdp_income_long, by = c("STATEFIP", "year"))


#filter out district of columbia
panel_clean <- panel_data %>%
  filter(STATEFIP != 11)

#summary of data
summary(panel_clean)
names(panel_clean)


```



```{r}
#check data distributions

#gdp 
ggplot(panel_clean, aes(x = real_gdp)) + geom_histogram(bins = 30, fill = "darkgreen", color = "black") + labs(title = "Distribution of GDP")

#income
ggplot(panel_clean, aes(x = real_per_capita_income)) + geom_histogram(bins = 30, fill = "darkblue", color = "white") + labs(title = "Distribution of Real Per Capita Income")

#minimum wage 
ggplot(panel_clean, aes(x = min_wage_real)) + geom_histogram(bins = 30, fill = "darkred", color = "white") + labs(title = "Distribution of Minimum Wage Across States")


#due to skewness of variables and common practice in research, some log transformations will be applied

#also creating dummy variable and log of one that looks okay distribution wise, but can be used down the line for robustness check
panel_clean2 <- panel_clean %>%
  mutate(log_gdp = log(pmax(real_gdp, 1)), 
         log_income = log(pmax(real_per_capita_income, 1)), 
         log_minw_real = log(pmax(min_wage_real, 1)), 
         treated_minw = as.integer(min_wage > 7.25))
  

#based on the scaling for poverty_rate, converting to a percent scale makes sense for ease of interpretability. 
panel_clean2 <- panel_clean2 %>%
  mutate(poverty_rate_pct = poverty_rate * 100, 
         STATEFIP = as.integer(STATEFIP), 
         year = as.integer(year))
```

```{r}
plot_data <- panel_clean2 %>%
  group_by(STATEFIP) %>%
  mutate(Group = ifelse(any(min_wage > 7.25), "Treated", "Control")) %>%
  ungroup()


ggplot(plot_data, aes(x = as.numeric(as.character(year)), y = poverty_rate_pct, color = Group)) + 
  stat_summary(fun = "mean", geom = "line", size = 1.2) + 
  stat_summary(fun = "mean", geom = "point", size = 2.5) + 
  labs(title = "Parallel Trends Check: Treated vs. Control States",
       subtitle = "Average poverty rates before and after minimum wage increases",
       x = "Year", y = "Mean Povery Rate", color = "Group") + 
  theme_minimal()

ggsave(filename = "parallel_trend_plot.png", dpi = 300)
```

The parallel trends plot compares the pre-treatment trajectories of mean poverty rates between states that enacted minimum wage increases (treated group) and those that did not ("control"). Prior to 2014, both groups follow roughly similar paths, with some variation around 2012 to 2014. Post-2014, both groups follow roughly similar paths, treated states exhibit a slightly higher level but maintain a broadly parallel movement, suggesting no sharp divergence in pre-trends. This visual evidence mostly supports the plausibility of parallel trends assumption required for difference-in-differences estimation, while indicating potential heterogeneity in post-treatment responses. 

```{r}
ggplot(panel_clean2, aes(x = poverty_rate_pct)) + geom_histogram(bins = 30, fill = "blue", color = "black") + labs(title = "Distribution of State-Year Poverty Rates")

```

```{r}
#poverty vs minimum wage
ggplot(panel_clean2, aes(x = log_minw_real, y = poverty_rate_pct)) + 
  geom_point(alpha = 0.6, color = "blue") + 
  geom_smooth(method = "lm", se = FALSE, color = "red", size = 1) + 
  labs(title = "Poverty vs. Minimum Wage", 
       x = "Log(Minimum Wage)", 
       y = "Poverty Rate") + theme_slide
```

The scatterplot shows a negative relationship between poverty rates and real per capita income across states and years. As income levels rise, poverty rates consistently decline, which aligns with economic theory that higher income improves household well-being and reduces the share of individuals living below the poverty threshold. The fitted regression line highlights a moderately strong downward slope, suggesting that even small proportional increases in per capita income are associated with measurable reductions in state-level poverty. This relationship provides early support for including real per capita income as a key control variable in assessing the effects of minimum wage policy on poverty.


```{r}
#poverty vs. income
ggplot(panel_clean2, aes(x = log_income, y = poverty_rate_pct)) +
  geom_point(alpha = 0.6, color = "black") + geom_smooth(method = "lm", se = FALSE, color = "orange", size = 1) + 
  labs(title = "Poverty (Percentage Points) vs Real Per Capita Income", x = "Log(Income)", y = "Poverty Rate") + theme_slide

ggsave(filename = "log_income_vs_poverty_rate.png", dpi = 400)
```

The relationship visualized between poverty rates and the log of minimum wage was also negative. though somewhat weaker and more dispersed than that observed for income. States with higher minimum wages generally exhibit lower poverty rates, but the wider scatter reflects that wage policy alone does not fully explain poverty variation across states. Still, the downward-sloping trend line indicates that increases in the minimum wage are correlated with lower poverty, supporting the hypothesis that higher wage floors can improve living standards for low-income workers. The visualization provides early evidence of the expected direction of the policy's impact. which will be tested more formally in the fixed-effects regressions. 

```{r}
panel_clean2 %>%
  group_by(treated_minw) %>%
  summarise(
    mean_poverty = mean(poverty_rate_pct, na.rm = T),
    mean_minw = mean(min_wage, na.rm = T),
    mean_income = mean(real_per_capita_income, na.rm = T),
    mean_unemp = mean(annual_unemp_sa, na.rm = T)
  )
```


```{r}
str(panel_clean2)
names(panel_clean2)

#function "feols" is having issues with finding STATEFIP even though it is in the dataset
vars_needed <- c("STATEFIP", "year", "poverty_rate_pct", "log_minw_real", "log_income", "log_gdp",
                 "unemployment_rate", "pop_weight")
setdiff(vars_needed, names(panel_clean2)) #returned character(0) so no actual issues with names



fe_model <- feols(
  poverty_rate_pct ~ log_minw_real + log_income + log_gdp + annual_unemp_sa | STATEFIP + year,
  data = panel_clean2,
  cluster = ~ STATEFIP,
  weights = ~ pop_weight,
)

summary(fe_model)

#polished results of fixed effects regression
etable(fe_model, digits = 3, title = "Fixed Effects Model: Poverty vs. Minimum Wage")
```

The two-way fixed effects output above, estimated with state and year fixed effects and population weights, revealed no statistically significant association between real minimum wage and state-level poverty rates among full-time low-wage workers. Although the coefficient on the log of minimum wage was positive, its large standard error indicates substantial uncertainty, and the overall within-state explanatory power of the model was minimal (within R2 of 0.007). These findings suggest that contemporaneous fixed effect estimates may obscure heterogeneous or lagged treatment effects, particularly in the context of staggered state-level minimum wage increases. Consequently, the next stage of analysis employs the staggered difference-in-differences framework proposed by Callaway & Sant'Anna (2021) to identify dynamic and heterogeneous policy effects over time. 

```{r}
coef_data <- tidy(fe_model, conf.int = T)

coef_data %>%
  filter(term == "log_minw_real") %>%
  ggplot(aes(x = term, y = estimate)) + 
  geom_point(color = "darkred", size = 3) + 
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2, color = "gray40") + 
  labs(title = "Effect of Log (Minimum Wage) on Poverty Rate", 
       x = "", y = "Estimated Coefficient") + theme_minimal()
``` 

The coefficient plot displays the estimated relationship between the log of minimum wage and the state-level poverty rate from the fixed effects regression. The red dot represents the point estimate, while the gray vertical line shows the 95% confidence interval. The estimate of approximately -0.012 indicates that, while holding constant real per capita income, real GDP, and unemployment, a 1% increase in the minimum wage is associated with roughly a 0.012 percentage point decrease in the poverty rate. Although the direction is negative

```{r}
coef_keep <- c("log_minw_real", "log_income", "log_gdp", "annual_unemp_sa")

coef_df <- tidy(fe_model, conf.int = T) %>%
  filter(term %in% coef_keep) %>%
  mutate(term = factor(term, 
                       levels = rev(coef_keep), 
                       labels = rev(c("Log (Min Wage)", "Log (Income Per Capita)", "Log (Real GDP)", "Unemployment Rate"))))

p_coef <- ggplot(coef_df, aes(x = term, y = estimate)) + 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high), size = 0.8) + 
  coord_flip() + labs(
    title = "Fixed Effects Model Coefficients", 
    subtitle = "State & Year FE; clustered by state; pop-weighted", 
    x = NULL, 
    y = "Estimated effect on poverty rate (pp)"
  ) + theme_slide

ggplot(coef_df, aes(x = term, y = estimate)) + 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high), size = 0.8) + 
  coord_flip() + labs(
    title = "Fixed Effects Model Coefficients", 
    subtitle = "State & Year FE; clustered by state; pop-weighted", 
    x = NULL, 
    y = "Estimated effect on poverty rate (pp)"
  ) + theme_slide

ggsave(filename = "Fixed_effects_coef_plot.png", dpi = 300)
```


```{r}
ipums_covariates <- ipums %>%
  filter(GQ %in% c(1,2)) %>%              
  group_by(STATEFIP, YEAR) %>%
  summarise(
    emp_rate = weighted.mean(EMPSTAT == 1, w = PERWT, na.rm = TRUE),
    lfpr = weighted.mean(LABFORCE == 2, w = PERWT, na.rm = TRUE),
    avg_hours = weighted.mean(UHRSWORK, w = PERWT, na.rm = TRUE),
    med_income = Hmisc::wtd.quantile(INCTOT, weights = PERWT, probs = 0.5),
    share_college = weighted.mean(EDUC >= 7, w = PERWT, na.rm = TRUE),
    share_black = weighted.mean(RACE == 2, w = PERWT, na.rm = TRUE),
    share_female = weighted.mean(SEX == 2, w = PERWT, na.rm = TRUE),
    share_foodstmp = weighted.mean(FOODSTMP == 2, w = PERWT, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(STATEFIP = as.integer(STATEFIP)) %>%
  filter(STATEFIP != 11)
```


```{r}
#identify treatment timing
#reflects each state's first year of a minimum-wage increase above baseline
panel_clean2 <- panel_clean2 %>%
  mutate(binding_nominal = min_wage > 7.25)
class(panel_clean2$STATEFIP)
class(ipums_covariates$STATEFIP)

panel_clean2 <- panel_clean2 %>%
  mutate(
    STATEFIP = as.integer(STATEFIP),
    year     = as.integer(year)
  )

ipums_covariates <- ipums_covariates %>%
  mutate(
    STATEFIP = as.integer(as.character(STATEFIP)),  
    YEAR     = as.integer(YEAR)
  )

panel_clean2 <- panel_clean2 %>%
  left_join(ipums_covariates %>% rename(year = YEAR), 
            by = c("STATEFIP", "year"))

#classification of states
by_state <- panel_clean2 %>%
  group_by(STATEFIP, state) %>%
  summarise(
    binding_2010 = any(min_wage > 7.25 & year == 2010),
    ever_binding = any(min_wage > 7.25, na.rm = TRUE),
    ever_unbound = any(!(min_wage > 7.25), na.rm = TRUE),
    first_treat  = ifelse(ever_binding & ever_unbound,
                          min(year[min_wage > 7.25], na.rm = TRUE),
                          NA_integer_),
    .groups = "drop"
  ) %>%
  mutate(
    group = case_when(
      binding_2010 & !ever_unbound ~ "always",
      !ever_binding                ~ "never",
      !binding_2010 & ever_binding ~ "adopter",
      TRUE                         ~ "other"
    ),
    first_treat = ifelse(group == "never", 0L, first_treat),
    first_treat = as.integer(first_treat)
  )


table(by_state$group)

length(intersect(unique(panel_clean2$STATEFIP), unique(ipums_covariates$STATEFIP)))
# should be ~50 (excluding DC)
sapply(c("emp_rate","med_income","share_college","share_foodstmp"),
       \(v) sum(is.na(panel_clean2[[v]])))
```



```{r}
#filter for staggered did
class(by_state$STATEFIP)
class(panel_clean2$STATEFIP)


stag_did <- panel_clean2 %>%
  left_join(by_state %>% select(STATEFIP, first_treat, group), by = "STATEFIP") %>%
  filter(group %in% c("adopter","never")) %>%
  mutate(STATEFIPS = as.integer(STATEFIP)) 

cohort_sizes <- stag_did %>%
  distinct(STATEFIPS, first_treat) %>%
  filter(first_treat != 0) %>%
  count(first_treat, name = "n_states") %>%
  arrange(first_treat)

valid_cohorts <- cohort_sizes %>% filter(n_states >= 4) %>% pull(first_treat)

stag_est <- stag_did %>%
  filter(first_treat %in% valid_cohorts | first_treat == 0L)

count(stag_est, first_treat, sort = TRUE)  # should show some 0s and some >0 cohorts
```



Going forward, the staggered DiD estimator requires adequate overlap and enough treated units within each adoption cohort to provide sable group-time effects. The cohort table provided above shows that several early and late adoption cohorts contain very few adopting states (i.e. 2011, 2012, 2021). To avoid weak identification, good prediction in the propensity step, and convergence/overlap failures, I intend to follow standard practice an exclude cohorts that are low in numbers.


```{r}
stag_est_win <- stag_est %>%
  mutate(event_time = if_else(first_treat == 0L, NA_integer_, year - first_treat)) %>%
  filter(is.na(event_time) | (event_time >= -3 & event_time <= 5))

stag_est_win <- stag_est_win %>%
  mutate(
    z_emp_rate   = scale(emp_rate)[,1],
    z_med_income = scale(med_income)[,1],
    z_college    = scale(share_college)[,1],
    z_snap       = scale(share_foodstmp)[,1],
    poverty_rate_pct = as.numeric(poverty_rate_pct)
  ) %>%
  drop_na(poverty_rate_pct, z_emp_rate, z_med_income, z_college, z_snap)
```




```{r}
#Timing of First minimum wage increases above 7.25 by year
by_state %>%
  filter(!STATEFIP %in% first_treat, !is.na(first_treat)) %>%
  ggplot(aes(x = as.factor(first_treat))) + 
  geom_bar(fill = "blue") + 
  labs(
    title = "Timing of First Minimum Wage Increases Above $7.25",
    x = "First Treatment Year", 
    y = "Number of States"
  ) + theme_minimal(base_size = 13)
```




```{r}
stag_est <- stag_est %>%
  mutate(STATEFIPS = as.integer(STATEFIP)) #new state identifier
att <- att_gt(
  yname = "poverty_rate_pct", 
  tname = "year", 
  idname = "STATEFIPS",
  gname = "first_treat",
  data = stag_est, 
  panel = T, 
  control_group = "nevertreated",
  clustervars = "STATEFIPS"
)

agg_overall <- aggte(att, type = "group") #overall att
agg_dyn <- aggte(att, type = "dynamic") #event-study
summary(agg_overall)
```

On average, states that raised the minimum wage experienced a 1.25 percentage-point lower poverty rate relative to the never-treated comparison group, after treatment. However, the confidence interval includes zero (p > 0.05), so this estimate is not statistically significant at conventional levels. Potentially weak results due to limited power of model with few cohorts. 

```{r}
summary(agg_dyn)
```

The table above shows effect by event time (years relative to adoption for states). Pre-treatment shows now systematic pattern (-4 to -1), but estimates fluctuate and CIs overlap zero, indicating no strong pre-trend bias that is apparent. At treatment (0 to +3), negative effects appear, suggesting poverty falls modestly after wage increases, though not precisely estimated. Effects fade, remain small, and statistically insignificant for long-run period (+4 to +12). The event-study pattern is consistent with a short-run reduction in poverty following minimum-wage increases but not large or persistent enough to reject the null with high confidence.


```{r}
prepost_ok <- stag_est_win %>%
  filter(first_treat != 0L) %>%
  group_by(STATEFIPS, first_treat) %>%
  summarise(
    has_pre  = any(year <  first_treat),
    has_post = any(year >= first_treat),
    .groups = "drop"
  ) %>%
  filter(has_pre & has_post) %>%
  pull(STATEFIPS)

stag_est_win <- stag_est_win %>%
  filter(first_treat == 0L | STATEFIPS %in% prepost_ok)

stag_est_win %>% filter(first_treat != 0L) %>%
  summarise(any_pre = any(event_time < 0, na.rm = TRUE),
            any_post = any(event_time >= 0, na.rm = TRUE))
```

```{r}
att_cov <- att_gt(
  yname = "poverty_rate_pct",
  tname = "year",
  idname = "STATEFIPS",
  gname = "first_treat",
  xformla = ~ z_emp_rate + z_med_income,
  data = stag_est_win,
  panel = F,
  control_group = "nevertreated",
  clustervars = "STATEFIPS"
)


```
 
```{r}
agg_overall_cov <- aggte(att_cov, type = "group",   na.rm = TRUE)
agg_dynamic_cov <- aggte(att_cov, type = "dynamic", na.rm = TRUE)

summary(agg_overall_cov)
summary(agg_dynamic_cov)

```
 
```{r}
p_dyn <- ggdid(agg_dynamic_cov) +
  labs(
    title    = "Event Study: Minimum Wage → Poverty",
    subtitle = "Callaway & Sant’Anna staggered DID (with controls)",
    x = "Years since first increase",
    y = "ATT (percentage points)"
  ) +
  theme_minimal(base_size = 14)

print(p_dyn)
```
 

 
```{r}
att_cov_nyt <- att_gt(
  yname = "poverty_rate_pct",
  tname = "year",
  idname = "STATEFIPS",
  gname = "first_treat",
  xformla = ~ z_emp_rate + z_med_income + z_college + z_snap,
  data = stag_est_win,
  panel = FALSE,
  control_group = "notyettreated",
  clustervars = "STATEFIPS"
)

agg_dynamic_nyt <- aggte(att_cov_nyt, type = "dynamic", na.rm = TRUE)
ggdid(agg_dynamic_nyt)
```
 
 